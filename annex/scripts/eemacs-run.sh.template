#!/usr/bin/env bash
# * Code
# pipe first command fail then fail
set -o pipefail
set -e
srcfile="${BASH_SOURCE[0]}"
while [ -h "$srcfile" ]; do # resolve $srcfile until the file is no longer a symlink
    srcdir="$( cd -P "$( dirname "$srcfile" )" >/dev/null && pwd )"
    srcfile="$(readlink "$srcfile")"

    # if $srcfile was a relative symlink, we need to resolve it relative
    # to the path where the symlink file was located
    [[ $srcfile != /* ]] && srcfile="$srcdir/$srcfile"
done
srcdir="$( cd -P "$( dirname "$srcfile" )" >/dev/null && pwd )"
cd "$srcdir"
set +e

# ** declare
emacs_exec="${EMACS:-emacs}"
emacs_session="${1:-main}"

# ** libs

function EemacsEcho ()
{
    local msg="$1"
    if command -v notify-send 1>/dev/null 2>&1
    then
        notify-send -t 3000 -a "$emacs_session" "$msg"
    fi
    echo -e "$1"
}

function EemacsTime ()
{
    date -u +"%Y%m%d%H%M%S"
}

function EemacsWarn ()
{
    EemacsEcho "\e[33m[warn: $(EemacsTime)] $1\e[0m"
}

function EemacsErro ()
{
    EemacsEcho "\e[31m[error: $(EemacsTime)] $1\e[0m"
    exit 1
}

function EemacsNerror ()
{
    if [ $? -ne 0 ]; then
        EemacsEcho "\e[31m[error: $(EemacsTime)] ${1:-some fatal occurs}\e[0m"
        exit 1
    fi
}

function EemacsJobMsg ()
{
    EemacsEcho "\e[32m[Job: $(EemacsTime)] $1 ...\e[0m"
}

function EemacsJobMsgSub ()
{
    EemacsEcho "--> \e[32m[SubJob: $(EemacsTime)] $1 ...\e[0m"
}

function EemacsOkMsg ()
{
    EemacsEcho "\e[32m[OK: $(EemacsTime)] $1\e[0m"
}

# ** login
cd ../../
EemacsNerror "CD to eemacs dir with fatal"
EEMACS_DIR="$(pwd)"
EemacsNerror "GET eemacs dir path with fatal"
cd "$EEMACS_DIR"
EemacsNerror "CD to $EEMACS_DIR with fatal"

# ** main

# TODO as your wish
