#+title: entropy-emacs bugs collection
#+author: Entropy

The bug collection for emacs recoreded for =entropy-emacs=.

* Introduction
:PROPERTIES:
:CUSTOM_ID: h-3a73ab13-b8f2-4023-bc71-adf0e0bce2e5
:END:

This file archives the bugs occurrence for using =entropy-emacs=, bugs
occurs both for =vanilla emacs= or =entropy-emacs=, since some bug are
natively of specific emacs release.

All the bug recorded in this file is recognized as one todo entry
uppon on the Org-Mode feature, using org-mode to manage the whole
toto-tree for those bugs.

The todo keys are mapped specially for =entropy-emacs=, with the
following valid keys:

1) =TODO= : indicating for repairing this bug, as the marked-up way,
   but with high priority.

2) =DOING= : the current bug repairing procedure including.

3) =DONE= : bug has been fixed up.

4) =HANGUP= : can not find the ideas for fixing this bug, hoped for
   help.

5) =MARKING= : minor bug doesn't affecting using but marked for
   remembering fixing as attitude for emacser.

6) =UPDATE= : Updating the previous "DONE" status for updating the new
   issue.

7) =CANCEL= : Canceling the bug fixing task as that its hopeless for
   as.

* Conribution
:PROPERTIES:
:CUSTOM_ID: h-84966099-8b8e-4765-89f2-5b8e4181d34a
:END:

Bug fixing PR are welcom, if you have fixed one bug or finding up the
bug caused source. The PR must using the TODO keywords refered to the
above demotion to update the bug entry status and giving the new
description for the corresponding sector.

Or oppsite for bug fixing PR, you can commit new bug to this file with
limitation of the bug of vanilla emacs or =entropy-emacs=.

* Bugs
:PROPERTIES:
:CUSTOM_ID: h-d7b20c2e-f395-4d35-bfdf-e12fc00cb7ad
:END:
** HANGUP Bug for 'yes-or-no-p' (founed when using 'doom-modeline'):
CLOSED: [2019-07-29 Mon 18:44]
:PROPERTIES:
:CUSTOM_ID: h-0c3ab89e-a470-42d2-946e-4f217ea2f20c
:END:

- State "HANGUP"     from "MARKING"    [2019-07-29 Mon 18:44] \\
  Has patched by specific 'kill-buffer' action, waiting for bug reply
  from emacs-bug-mailist.


*Bug description:*

If using the modeline who using all-the-icons as the segments'
component, that when using pop-up window to show 'ansi-term' will
cause the problem during 'kill-buffer' operation for the spawn process
kill confirmation returns the error for that:

``` error-info
Debugger entered--Lisp error: (error "Selecting deleted buffer")
term-emulate-terminal(#<process *ansi-term*> "your-shell-$ps1")
```
But when you using the 'y-or-n-p' redefine the 'yes-or-no-p', its
gone.

The bug trigger also referred to font setting that if using some fonts
specific (e.g. liberation-mono fonts) unless the google-noto family
will get the error when the 'yes-or-no-p' redefination not did as
demoted in above paragraph.

*Bug Reproduce:*

1) Operation Environment:

   Platform: GNU/Linux
   Distro: Manjaro (4.19.60-1-MANJARO GNU/Linux)
   Emacs-Version: 26.x all serial
   Emacs Configuration: Vanilla

2) Put below elisp snippet into `init.el`

   #+BEGIN_SRC elisp
     (package-initialize)
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (setq package-archives '(("gnu"   . "http://elpa.gnu.org/packages/")
                              ("melpa" . "http://melpa.org/packages/")
                              ("org"   . "https://orgmode.org/elpa/")))

     ;; Please install 'liberation-ttf' first
     (set-face-attribute 'default nil :family "Liberation Mono" :font "Liberation Mono")

     (defun temp/test-bug ()
       (interactive)
       (when (not (one-window-p))
         (delete-other-windows)
         (about-emacs))
       (let ((_w (split-window
                  (selected-window)
                  25
                  'below)))
         (select-window _w)
         (ansi-term "bash")
         (setq-local kill-buffer-hook nil)))

     (global-set-key (kbd "<f9>") #'temp/test-bug)

     (global-set-key (kbd "C-x k") 'kill-buffer-and-window)

     (unless (package-installed-p 'doom-modeline)
       (package-refresh-contents)
       (package-install 'doom-modeline))

     (doom-modeline-mode)
   #+END_SRC

3) Start emacs and hit '<f9>', then try to kill the selected buffer

   Notice: the "yes-or-no" input string must type correcly at the firt
   input time, otherwise the bug reproduce will not did as expecting.

** MARKING Ibus input bug for full-screen occurrence  (entropy-emacs only) :entropy-emacs:
:PROPERTIES:
:CUSTOM_ID: h-74ea996b-2f5d-4872-b5e8-2dc152e466a1
:END:

- State "MARKING"    from              [2019-07-31 Wed 01:20]


#+BEGIN_EXAMPLE
OS: Manjaro Linux (Linux 4.19.60-1-MANJARO #1 SMP PREEMPT Sun Jul 21 12:17:26 UTC 2019 x86_64 GNU/Linux)
neofetch:

entropy@entropy-pc
██████████████████  ████████   ------------------
██████████████████  ████████   OS: Manjaro Linux x86_64
██████████████████  ████████   Host: Satellite L700 PSK12Q-01600D
████████            ████████   Kernel: 4.19.60-1-MANJARO
████████  ████████  ████████   Uptime: 13 hours, 51 mins
████████  ████████  ████████   Packages: 1284 (pacman)
████████  ████████  ████████   Shell: bash 5.0.7
████████  ████████  ████████   Resolution: 1366x768
████████  ████████  ████████   DE: GNOME 3.32.2
████████  ████████  ████████   Theme: Matcha-dark-sea [GTK2/3]
████████  ████████  ████████   Icons: Papirus-Dark-Maia [GTK2/3]
████████  ████████  ████████   Terminal: gnome-terminal
████████  ████████  ████████   CPU: Intel i5-2410M (4) @ 2.900GHz
                               GPU: NVIDIA GeForce GT 525M
                               Memory: 2831MiB / 5941MiB

#+END_EXAMPLE

1) Bug description:

   When using ibus (cjk backend of =rime=) in emacs for full-screen
   occurrence, the ime-tooltip display will disapear after few chars
   typing. it's so strange.

2) Influences aspects suspects

   - Font spec configuration (e.g. =entropy-emacs-font-set.el=)
   - Ui spec configurations
   - global-disable-mouse-mode
   - shackle window popup feature (ibus tooltip losst when popout the
     shackle buffer at the first time)

** DONE =solaire-mode= can not working correctly in pdumper-session
CLOSED: [2019-09-09 Mon 05:42]
:PROPERTIES:
:CUSTOM_ID: h-86e0180b-bcf0-484d-bc21-9502d8abeb58
:END:

- State "MARKING"    from              [2019-08-24 Sat 19:27]


1) Bug description:

The emacs session of pdumper loaded type can not covering solaire-mode
feature fully, the solaired buffer has no significant color rendering
efficient, that the solaired buffer has the same color face as the
non-solaired buffer.

1) Influences aspects suspects

   1) Pdumper session lost some features relied by ~solaire-mode~.
   2) This must try another way to configured ~solaire-mode~ with
      pdumper session.


Resolutions:

Its because of that the function ~solaire-mode-swap-bg~ can not used
in theme after procedure hook, in eemacs like
=entropy/emacs-theme-load-after-hook=, its may be a bug that the we
should do the ~solaire-mode-swap-bg~ operation using the idle timer.

** DONE Face spec for posframe not effectived for =posframe= in *pdumper* session
CLOSED: [2020-05-04 Mon 18:56]
:PROPERTIES:
:CUSTOM_ID: h-9ea04c28-bdbe-4099-80b2-c97ba373e62b
:END:

This bug may has the same core issue with [[h-86e0180b-bcf0-484d-bc21-9502d8abeb58][this]].

1) Bug description:

   When using =entropy-sdcv= of its tool-tip show feature, the
   posframe's foreground may not specified by its subroutine
   correctly while after change theme by
   `entropy/emacs-ivy-counsel-load-theme', this bug occurred for while
   the fixing patch for [[h-86e0180b-bcf0-484d-bc21-9502d8abeb58][this]].


Bug has been fixed by [[h-86e0180b-bcf0-484d-bc21-9502d8abeb58][this issue]]

** DONE Hydra ruby doc area can not using underscore char '_' as key notation
CLOSED: [2020-05-04 Mon 18:53]
:PROPERTIES:
:CUSTOM_ID: h-a8ab8a75-1c4d-4df7-859f-a09c58345b82
:END:

- State "DONE"       from "DOING"      [2020-05-04 Mon 18:53]
- State "DOING"      from              [2020-03-05 Thu 21:07]
This bug was push the issue to hydra official project page's [[https://github.com/abo-abo/hydra/issues/366][issue
block]].

*Bug description: *

#+begin_example
Hi hydra maintainer:

I've temporary define a hydra on vanilla emacs env (27.0.90):

(defhydra temp/hydra
  (:hint nil :exit nil :foreign-keys nil)
  "

 temp/hydra

 Common Insert^^
─────────────────────────────────────────────────────────────────────────────────
 _C-c C-,_: Insert a block structure of the type #+begin_foo/#+end_foo
"
  ("C-c C-," org-insert-structure-template :exit t))

With follow warning:
Warning (emacs): Unrecognized key: foo/#+end

Its the bug when the key notation part contained '_' char, is that the ruby doc format limitation which can not using the underscore char in the key notation part (just can used in key stroke region)? Or is their a backslash escape like method to avoid thats strange doc defination?

I known this issue was strained, but what I want is let 'hydra' be more stronger smiley , hope for your help.

Thanks for your greate contribution!
#+end_example

Bug has been fixed by upstream.

** DOING Hydra can not bind key with underscore char "_"
:PROPERTIES:
:CUSTOM_ID: h-37da4ec7-7317-4172-b23c-c03de78760a5
:END:

- State "DOING"      from              [2020-03-05 Thu 21:08]



This bug was the older one, that hasn't been fixed til now, you can
found the reflect github issue [[https://github.com/abo-abo/hydra/issues/161][here]].

** MARKING Treemacs overlay markers puts procedure interrupt while ~lsp-configure-buffer~
:PROPERTIES:
:CUSTOM_ID: h-6610e0a1-e68b-4541-a814-fe3214363866
:END:

- State "MARKING"    from "TODO"       [2021-01-08 Fri 23:30]


This is a bug for treemacs that enable `lsp-configure-buffer' while
`treemacs-follow-mode' is t at the same time, the overlay markers in
treemacs buffer which will cause definitely internal error for the
usage for treemacs after thus, including any face rendering and
operations expecting the correct of overlay marks.

Further more, this bug will may also raise up an strange bug that the
point in treemacs buffer will jump to buffer top when typiing in an
lsp enabled buffer.

For now [2021-01-08 Fri 23:31:17] there's one temporally fixed up
solution that temporally disable =treemacs-follow-mode= before lsp
enable in certain buffer, and then reenable it after thus.

NOTE: may need to report to treemacs author.


** MARKING =lsp-ui-doc-mode= mouse scroll while eobp freeze emacs
:PROPERTIES:
:CUSTOM_ID: h-c02794e4-bdb8-4510-84cb-d668873b02fc
:END:

- State "MARKING"    from              [2021-01-19 Tue 07:41]
Related to bug ->
https://github.com/emacs-lsp/lsp-ui/issues/530#issuecomment-762305991

this will make lsp-ui-doc frame freeze emacs while `mwheel-scroll'
down to the eobp of lsp-doc-buffer.

#+begin_quote
Of counse, the issue is referred to an monuse-wheel problem, after
view hours investigating lsp-ui-doc source where I can not judge the
problem sticker yet but finally focus on one emacs customization: the
mouse-wheel-scroll-amount variable which is the pain for thus did
occur on :

You can set it with (setq mouse-wheel-scroll-amount '(1 ((shift)
. 1))) while the amount default is 5, but many user including me set
it to 1 or any other value less than 5 for the sake of "smooth
scrolling" , Uh.. , the freezing occurred.

This may an emacs internal bug, but I can not ensure that is it,
because, it didn't occurred in the stable version of `lsp-ui' , just
after we use the more mordern doc buffer renderring mechanism, is it?
#+end_quote

*** Update: 2021-01-23 Sat 15:34:16
:PROPERTIES:
:CUSTOM_ID: h-467a7c85-5c2b-4d84-97f4-82eb8f1cc418
:END:

This caused by both of above and follow:
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC

Thus for now we can built the reproducible template via vanilla emacs:

Run [[./h-c02794e4-bdb8-4510-84cb-d668873b02fc/run.sh]]

With manually hover reproduced of:
#+begin_quote
Please hover the mounse on the symbol `scanf' or `main' on test.c
buffer thens scroll the lsp-ui-doc frame window by mounse-wheel,
then the bug will be occurred with freezing session, and beeping
sequentially while emacs bell ring is not null.

If the bug not occurred try enter <f11> let emacs judging into
fullscreen and redo above section, this may occurred as well.
#+end_quote


** TODO emacs internal api =looking-back= freeze emacs
:PROPERTIES:
:CUSTOM_ID: h-f551b679-908f-4b64-b08e-e7074d17581e
:END:

This bug caused from an =company-dabbrev-char-regexp= setting of
regexp "[-_/a-zA-Z0-9]+", then the company's dabbrev backend will
invoke the =looking-back= subrouine to determine its matching scope
which used in function =company-grab= which invoked by function
=company-dabbrev--prefix=.

It seems related to the =looking-back= performance issue which
discussed [[https://emacs.stackexchange.com/questions/12742/looking-back-performance][here]]. But since we used *LIMIT* optional in the invocation,
it still lag on, which I'd thought its an emacs bug.

*Reproduce steps:*

Run the =run.sh= in =./h-f551b679-908f-4b64-b08e-e7074d17581e=

** TODO bug of ~ivy-reverse-i-search~ 'ivy-call: Wrong type argument: listp, "..."'
:PROPERTIES:
:CUSTOM_ID: h-17036bdc-c6e9-4ac2-bac8-1c55bd8ecda4
:END:

The bug caused by mis-match canid selected in 'ivy-history' and the
any action of the 'ivy-state' will throw an error such like:
#+begin_example
  Debugger entered--Lisp error: (wrong-type-argument listp "")
    #f(compiled-function (x) #<bytecode 0x155d83410191>)("")
    ivy-call()
    #f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x1fce82fc2293>)("Reverse-i-search: " nil :keymap (keymap (11 . ivy-reverse-i-search-kill)) :action #f(compiled-function (x) #<bytecode 0x155d83410191>) :caller ivy-reverse-i-search)
    apply(#f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x1fce82fc2293>) ("Reverse-i-search: " nil :keymap (keymap (11 . ivy-reverse-i-search-kill)) :action #f(compiled-function (x) #<bytecode 0x155d83410191>) :caller ivy-reverse-i-search))
    ivy-read("Reverse-i-search: " nil :keymap (keymap (11 . ivy-reverse-i-search-kill)) :action #f(compiled-function (x) #<bytecode 0x155d83410191>) :caller ivy-reverse-i-search)
    ivy-reverse-i-search()
    funcall-interactively(ivy-reverse-i-search)
    call-interactively(ivy-reverse-i-search nil nil)
    command-execute(ivy-reverse-i-search)
    read-from-minibuffer("sdfsf" nil (keymap keymap (67108910 lambda nil (interactive) (message "You can not using xref functions in minibuffer")) (36 . ivy-magic-read-file-env) (3 keymap (19 . ivy-rotate-sort) (1 . ivy-toggle-ignore) (15 . ivy-occur)) (33554464 . ivy-restrict-to-matches) (15 . hydra-ivy/body) (22 . ivy-scroll-up-command) (prior . ivy-scroll-down-command) (next . ivy-scroll-up-command) (7 . minibuffer-keyboard-quit) (right . ivy-forward-char) (32 . self-insert-command) (18 . ivy-reverse-i-search) (remap keymap (describe-mode . ivy-help) (kill-ring-save . ivy-kill-ring-save) (kill-whole-line . ivy-kill-whole-line) (kill-line . ivy-kill-line) (scroll-down-command . ivy-scroll-down-command) (scroll-up-command . ivy-scroll-up-command) (end-of-buffer . ivy-end-of-buffer) (beginning-of-buffer . ivy-beginning-of-buffer) (kill-word . ivy-kill-word) (forward-char . ivy-forward-char) (delete-char . ivy-delete-char) (backward-kill-word . ivy-backward-kill-word) (backward-delete-char-untabify . ivy-backward-delete-char) (delete-backward-char . ivy-backward-delete-char) (previous-line . ivy-previous-line) (next-line . ivy-next-line)) (9 . ivy-partial-or-done) (10 . ivy-alt-done) (27 keymap (67108910 lambda nil (interactive) (message "You can not using xref functions in minibuffer")) (44 lambda nil (interactive) (message "You can not using xref functions in minibuffer")) (46 lambda nil (interactive) (message "You can not using xref functions in minibuffer")) (1 . ivy-read-action) (15 . ivy-dispatching-call) (111 . ivy-dispatching-done) (25 . ivy-insert-current-full) (105 . ivy-insert-current) (106 . ivy-yank-word) (114 . ivy-toggle-regexp-quote) (97 . ivy-toggle-marks) (16 . ivy-previous-line-and-call) (14 . ivy-next-line-and-call) (118 . ivy-scroll-down-command) (112 . ivy-previous-history-element) (110 . ivy-next-history-element) (10 . ivy-immediate-done) (13 . ivy-call)) (mouse-3 . ivy-mouse-dispatching-done) (mouse-1 . ivy-mouse-done) (down-mouse-1 . ignore) (13 . ivy-done)) nil ivy-history)
    #f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x1fce82fc2293>)("sdfsf" (sdfasfasd safsadf) :action (closure (t) (x) (setq temp/xx x)))
    apply(#f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x1fce82fc2293>) ("sdfsf" (sdfasfasd safsadf) :action (closure (t) (x) (setq temp/xx x))))
    ivy-read("sdfsf" (sdfasfasd safsadf) :action (closure (t) (x) (setq temp/xx x)))
    (progn (ivy-read "sdfsf" '(sdfasfasd safsadf) :action #'(lambda (x) (setq temp/xx x))))
    eval((progn (ivy-read "sdfsf" '(sdfasfasd safsadf) :action #'(lambda (x) (setq temp/xx x)))) t)
    elisp--eval-last-sexp(nil)
    eval-last-sexp(nil)
    funcall-interactively(eval-last-sexp nil)
    call-interactively(eval-last-sexp nil nil)
    command-execute(eval-last-sexp)
#+end_example

The simple reputation can be calling an simple =ivy-read= context:
#+begin_src elisp
  (ivy-read "input sth: "
            '("a" "b"))
#+end_src
Run above code and =\C-r= to trigger the ~ivy-reverse-i-search~ the
input any code and =RET= trigger ~ivy-done~ then the error occurred
(note: please toggle on debug to see the details).

For now mine temporally fixed method is to assign the =require-match=
to its subroutine which forcely ignore any non-matched selection.

** TODO bug of `run-with-idle-timer' with 0 idle delay in emacs start up time
:PROPERTIES:
:CUSTOM_ID: h-6d28b926-88c0-4286-a0de-9ee7b4a7516c
:END:

When emacs is startup with an idle timer as end procedure in
=init.el=, then there're two pre-typed char =[= and =I= are preformed
into the echo area of that timer.

- Reproduce: [[./h-6d28b926-88c0-4286-a0de-9ee7b4a7516c/start-bug.sh]]

  We can not reproduce in arbitary environment, since it seems related
  to the shell env the emacs start at, espacially in tmux session.

- Temporally resolve dealing: set the idle delay closed to 0 but not
  approach to it.

*** log: [2021-09-25 Sat 22:03:52]:
:PROPERTIES:
:CUSTOM_ID: h-8b80c803-94a9-4208-b309-2c00aca1a784
:END:

It seems that the idle delay less than 0.001 also will trigger this
bug.

*** log: [2021-10-01 Fri 23:13:38]
:PROPERTIES:
:CUSTOM_ID: h-60551428-a42b-4c82-833f-d12c31372577
:END:

It seems related to X11 protocal on linux of gnome DE since it
disappeared while using Xwayland gnome session.

** TODO bug of system IME (e.g. fcitx) let emacs GUI fast hints hang without any response in linux desktop
:PROPERTIES:
:CUSTOM_ID: h-12379f67-4311-4433-86e3-a6fdfd886112
:END:

Some IME (input method editor) hang emacs without any response in GUI
mode in Gnome shell while fast scroll screen using arrow down/up
(i.e. ~next-line~ / ~previous-line~) with fast repeat key typing
enable in system setting or keyboard hardware embedded utils.

The only way currently to fix this is to disable the IME in whole
emacs session's environment:
#+begin_src shell
unset GTL_IM_MODULE
unset GTK_IM_MODULE
unset QT_IM_MODULE
unset XMODIFIERS
exec emacs "$@"
#+end_src

Put above be the emacs.sh or other caller format with example or just
unseet these environment variable.

Or modify the desktop file or the desktop custom keyboard shortcut for
as ~EXEC=env GTL_IM_MODULE= GTK_IM_MODULE= QT_IM_MODULE= XMODIFIERS= emacs %F~ or
~env GTL_IM_MODULE= GTK_IM_MODULE= QT_IM_MODULE= XMODIFIERS= emacs~.

** DONE bug of =large-file-warning-threshold= is nil in some occasions
CLOSED: [2022-05-05 Thu 14:46]
:PROPERTIES:
:CUSTOM_ID: h-ca204a62-9e15-4f3b-ae23-f31b6046a9c5
:END:
- State "MARKING"    from "UPDATE"     [2022-02-06 Sun 07:56]
=large-file-warning-threshold= is nil in some occasions even if we
bind it in top level.

See below baacktrace:

#+begin_example
  Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p nil)
    >(20257471 nil)
    (or (> (buffer-size) large-file-warning-threshold) (progn (require 'so-long) (let ((so-long-threshold __unreadable-file-long-threshold)) (so-long-detected-long-line-p))))
    (save-current-buffer (set-buffer buff) (or (> (buffer-size) large-file-warning-threshold) (progn (require 'so-long) (let ((so-long-threshold __unreadable-file-long-threshold)) (so-long-detected-long-line-p)))))
    (lambda (buff) (save-current-buffer (set-buffer buff) (or (> (buffer-size) large-file-warning-threshold) (progn (require 'so-long) (let ((so-long-threshold __unreadable-file-long-threshold)) (so-long-detected-long-line-p))))))(#<buffer tempfile.txt>)
    funcall((lambda (buff) (save-current-buffer (set-buffer buff) (or (> (buffer-size) large-file-warning-threshold) (progn (require 'so-long) (let ((so-long-threshold __unreadable-file-long-threshold)) (so-long-detected-long-line-p)))))) #<buffer tempfile.txt>)
    (if (funcall entropy/emacs-unreadable-buffer-judge-function (current-buffer)) nil (entropy/emacs-basic-smooth-scrolling-mode 1))
    entropy/emacs-basic-smooth-scrolling-mode-turn-on()
    (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on))
    (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)))
    (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on))))
    (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)))) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode))
    (progn (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)))) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode)))
    (if (buffer-live-p buf) (progn (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn (entropy/emacs-basic-smooth-scrolling-mode -1) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)))) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode))))
    (while --dolist-tail-- (setq buf (car --dolist-tail--)) (if (buffer-live-p buf) (progn (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode (progn ... ...) (entropy/emacs-basic-smooth-scrolling-mode-turn-on)))) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode)))) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (let ((--dolist-tail-- buffers) buf) (while --dolist-tail-- (setq buf (car --dolist-tail--)) (if (buffer-live-p buf) (progn (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if (eq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode) nil (if entropy/emacs-basic-smooth-scrolling-mode ... ...))) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode)))) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((buffers entropy/emacs-basic-smooth-scrolling-global-mode-buffers)) (setq entropy/emacs-basic-smooth-scrolling-global-mode-buffers nil) (let ((--dolist-tail-- buffers) buf) (while --dolist-tail-- (setq buf (car --dolist-tail--)) (if (buffer-live-p buf) (progn (save-current-buffer (set-buffer buf) (if entropy/emacs-basic-smooth-scrolling-mode-set-explicitly nil (if ... nil ...)) (setq entropy/emacs-basic-smooth-scrolling-mode-major-mode major-mode)))) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    entropy/emacs-basic-smooth-scrolling-global-mode-enable-in-buffers()
    run-hooks(change-major-mode-after-body-hook after-change-major-mode-hook)
    normal-mode(t)
    after-find-file(nil t)
    find-file-noselect-1(#<buffer tempfile.txt> "/tmp/tempfile.txt" nil nil "/tmp/he..." (878091 41))
    #f(compiled-function (filename &optional nowarn rawfile wildcards) "Read file FILENAME into a buffer and return the buffer.\nIf a buffer exists visiting FILENAME, return that one, but\nverify that the file has not changed since visited or saved.\nThe buffer is not selected, just returned to the caller.\nOptional second arg NOWARN non-nil means suppress any warning messages.\nOptional third arg RAWFILE non-nil means the file is read literally.\nOptional fourth arg WILDCARDS non-nil means do wildcard processing\nand visit all the matching files.  When wildcards are actually\nused and expanded, return a list of buffers that are visiting\nthe various files." #<bytecode 0x1febf8f6552d>)("/tmp/tempfile.txt")
    apply(#f(compiled-function (filename &optional nowarn rawfile wildcards) "Read file FILENAME into a buffer and return the buffer.\nIf a buffer exists visiting FILENAME, return that one, but\nverify that the file has not changed since visited or saved.\nThe buffer is not selected, just returned to the caller.\nOptional second arg NOWARN non-nil means suppress any warning messages.\nOptional third arg RAWFILE non-nil means the file is read literally.\nOptional fourth arg WILDCARDS non-nil means do wildcard processing\nand visit all the matching files.  When wildcards are actually\nused and expanded, return a list of buffers that are visiting\nthe various files." #<bytecode 0x1febf8f6552d>) "/tmp/tempfile.txt")
    (let ((find-file-visit-truename (and (not (equal filename ftruename)) (not (file-directory-p filename))))) (apply orig-func orig-args))
    (let* ((filename (let* ((path (car orig-args))) (if (and (> (length path) 1) (eq 47 (aref path ...))) (substring path 0 -1) path))) (rest (cdr orig-args)) (ftruename (let* ((path (file-truename filename))) (if (and (> (length path) 1) (eq 47 (aref path ...))) (substring path 0 -1) path)))) (let ((find-file-visit-truename (and (not (equal filename ftruename)) (not (file-directory-p filename))))) (apply orig-func orig-args)))
    (if (__entropy/emacs-init-tramp-file-p (car orig-args)) (apply orig-func orig-args) (let* ((filename (let* ((path (car orig-args))) (if (and (> ... 1) (eq 47 ...)) (substring path 0 -1) path))) (rest (cdr orig-args)) (ftruename (let* ((path (file-truename filename))) (if (and (> ... 1) (eq 47 ...)) (substring path 0 -1) path)))) (let ((find-file-visit-truename (and (not (equal filename ftruename)) (not (file-directory-p filename))))) (apply orig-func orig-args))))
    entropy/emacs--dwim-abs-find-file(#f(compiled-function (filename &optional nowarn rawfile wildcards) "Read file FILENAME into a buffer and return the buffer.\nIf a buffer exists visiting FILENAME, return that one, but\nverify that the file has not changed since visited or saved.\nThe buffer is not selected, just returned to the caller.\nOptional second arg NOWARN non-nil means suppress any warning messages.\nOptional third arg RAWFILE non-nil means the file is read literally.\nOptional fourth arg WILDCARDS non-nil means do wildcard processing\nand visit all the matching files.  When wildcards are actually\nused and expanded, return a list of buffers that are visiting\nthe various files." #<bytecode 0x1febf8f6552d>) "/tmp/tempfile.txt")
    apply(entropy/emacs--dwim-abs-find-file #f(compiled-function (filename &optional nowarn rawfile wildcards) "Read file FILENAME into a buffer and return the buffer.\nIf a buffer exists visiting FILENAME, return that one, but\nverify that the file has not changed since visited or saved.\nThe buffer is not selected, just returned to the caller.\nOptional second arg NOWARN non-nil means suppress any warning messages.\nOptional third arg RAWFILE non-nil means the file is read literally.\nOptional fourth arg WILDCARDS non-nil means do wildcard processing\nand visit all the matching files.  When wildcards are actually\nused and expanded, return a list of buffers that are visiting\nthe various files." #<bytecode 0x1febf8f6552d>) "/tmp/tempfile.txt")
    find-file-noselect("/tmp/tempfile.txt")
    (let* ((fnew-p nil) (fname (if (file-exists-p filename) filename (setq fnew-p t) (if do-read (user-error "[error] Please do read from an exist file!") (hexie/subr-touch-file filename) filename))) (inhibit-read-only t) (large-file-warning-threshold nil) (buffer (find-file-noselect filename))) (if (null do-read) (if (or fnew-p (or force-renew (yes-or-no-p "Renew it? "))) (progn (save-current-buffer (set-buffer buffer) (delete-region (point-min) (point-max)) (hexie/subr-insert-sexp hexie/api-core-database) (save-buffer)))) (save-current-buffer (set-buffer buffer) (goto-char (point-min)) (setq hexie/api-core-database (hexie/subr-receive-sexp)))) (kill-buffer buffer))
    hexie/api-core-database-save/read("/tmp/tempfile.txt" t)
    funcall-interactively(hexie/api-core-database-save/read "/tmp/tempfile.txt" t)
    call-interactively(hexie/api-core-database-save/read record nil)
    command-execute(hexie/api-core-database-save/read record)
    counsel-M-x-action("hexie/api-core-database-save/read")
    ivy-call()
    #f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x155ee0a9b5c5>)("M-x " [__adv/around/entropy/emacs-individual-hydra--entropy/emacs-hydra-hollow-top-dispatch--hydra-category-1-caller/hl-todo-previous-and-exit/with-pretty-hydra-hack localp ada-ref-man epg-context-signers locals 0 tramp-compat-exec-path xselect--int-to-cons __adv/around/entropy/emacs-individual-hydra--entropy/emacs-individual-hydra-random-name-of-6--hydra-category-0-caller/body/__use-posframe-show avy-words epg--status-VALIDSIG all-the-icons-ivy-rich--project-file-path eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_17 eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_18 org-emphasis-regexp-components Sarasa\ Fixed\ J tramp-gvfs-handle-copy-file tramp-do-copy-or-rename-file-out-of-band entropy/emacs-org-keymap-group-$common-open hexie/subr-org-subhead-exists-p _message hexie/api-core-registry-pos-obj eemacs-use-package/hydra-hollow-defer-parse/for-entropy-open-with/judger-id_59 Backward\ 1\ Year cl-print--preprocess Find\ file\ in\ directory selinux-context Insert\ Diary\ Entry wicon archive_type conf-space-mode-map 0 cl--struct-epg-signature-p entropy/cl-read-file-name \" cpbdins $ test-command Info-apropos-find-file \' :name-match M-kp-down tramp-cache-data org-babel-results-keyword eglot-autoshutdown dont-create not-at-beginning-of-line f-empty\? expired calendar-debug-sexp ...] :predicate #f(compiled-function (sym) #<bytecode 0x155ee121eced>) :require-match t :history counsel-M-x-history :action counsel-M-x-action :keymap (keymap (67108908 . counsel--info-lookup-symbol) (67108910 . counsel-find-symbol)) :initial-input nil :caller counsel-M-x)
    apply(#f(compiled-function (arg1 arg2 &rest rest) "Read a string in the minibuffer, with completion.\n\nPROMPT is a string, normally ending in a colon and a space.\n`ivy-count-format' is prepended to PROMPT during completion.\n\nCOLLECTION is either a list of strings, a function, an alist, or\na hash table, supplied for `minibuffer-completion-table'.\n\nPREDICATE is applied to filter out the COLLECTION immediately.\nThis argument is for compatibility with `completing-read'.\n\nWhen REQUIRE-MATCH is non-nil, only members of COLLECTION can be\nselected.\n\nIf INITIAL-INPUT is non-nil, then insert that input in the\nminibuffer initially.\n\nHISTORY is a name of a variable to hold the completion session\nhistory.\n\nKEYMAP is composed with `ivy-minibuffer-map'.\n\nPRESELECT, when non-nil, determines which one of the candidates\nmatching INITIAL-INPUT to select initially.  An integer stands\nfor the position of the desired candidate in the collection,\ncounting from zero.  Otherwise, use the first occurrence of\nPRESELECT in the collection.  Comparison is first done with\n`equal'.  If that fails, and when applicable, match PRESELECT as\na regular expression.\n\nDEF is for compatibility with `completing-read'.\n\nUPDATE-FN is called each time the candidate list is re-displayed.\n\nWhen SORT is non-nil, `ivy-sort-functions-alist' determines how\nto sort candidates before displaying them.\n\nACTION is a function to call after selecting a candidate.\nIt takes one argument, the selected candidate. If COLLECTION is\nan alist, the argument is a cons cell, otherwise it's a string.\n\nMULTI-ACTION, when non-nil, is called instead of ACTION when\nthere are marked candidates. It takes the list of candidates as\nits only argument. When it's nil, ACTION is called on each marked\ncandidate.\n\nUNWIND is a function of no arguments to call before exiting.\n\nRE-BUILDER is a function transforming input text into a regex\npattern.\n\nMATCHER is a function which can override how candidates are\nfiltered based on user input.  It takes a regex pattern and a\nlist of candidates, and returns the list of matching candidates.\n\nDYNAMIC-COLLECTION is a boolean specifying whether the list of\ncandidates is updated after each input by calling COLLECTION.\n\nEXTRA-PROPS is a plist that can be used to store\ncollection-specific session-specific data.\n\nCALLER is a symbol to uniquely identify the caller to `ivy-read'.\nIt is used, along with COLLECTION, to determine which\ncustomizations apply to the current completion session." #<bytecode 0x155ee0a9b5c5>) ("M-x " [__adv/around/entropy/emacs-individual-hydra--entropy/emacs-hydra-hollow-top-dispatch--hydra-category-1-caller/hl-todo-previous-and-exit/with-pretty-hydra-hack localp ada-ref-man epg-context-signers locals 0 tramp-compat-exec-path xselect--int-to-cons __adv/around/entropy/emacs-individual-hydra--entropy/emacs-individual-hydra-random-name-of-6--hydra-category-0-caller/body/__use-posframe-show avy-words epg--status-VALIDSIG all-the-icons-ivy-rich--project-file-path eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_17 eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_18 org-emphasis-regexp-components Sarasa\ Fixed\ J tramp-gvfs-handle-copy-file tramp-do-copy-or-rename-file-out-of-band entropy/emacs-org-keymap-group-$common-open hexie/subr-org-subhead-exists-p _message hexie/api-core-registry-pos-obj eemacs-use-package/hydra-hollow-defer-parse/for-entropy-open-with/judger-id_59 Backward\ 1\ Year cl-print--preprocess Find\ file\ in\ directory selinux-context Insert\ Diary\ Entry wicon archive_type conf-space-mode-map 0 cl--struct-epg-signature-p entropy/cl-read-file-name \" cpbdins $ test-command Info-apropos-find-file \' :name-match M-kp-down tramp-cache-data org-babel-results-keyword eglot-autoshutdown dont-create not-at-beginning-of-line f-empty\? expired calendar-debug-sexp ...] :predicate #f(compiled-function (sym) #<bytecode 0x155ee121eced>) :require-match t :history counsel-M-x-history :action counsel-M-x-action :keymap (keymap (67108908 . counsel--info-lookup-symbol) (67108910 . counsel-find-symbol)) :initial-input nil :caller counsel-M-x))
    ivy-read("M-x " [__adv/around/entropy/emacs-individual-hydra--entropy/emacs-hydra-hollow-top-dispatch--hydra-category-1-caller/hl-todo-previous-and-exit/with-pretty-hydra-hack localp ada-ref-man epg-context-signers locals 0 tramp-compat-exec-path xselect--int-to-cons __adv/around/entropy/emacs-individual-hydra--entropy/emacs-individual-hydra-random-name-of-6--hydra-category-0-caller/body/__use-posframe-show avy-words epg--status-VALIDSIG all-the-icons-ivy-rich--project-file-path eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_17 eemacs-use-package/hydra-hollow-defer-parse/for-shackle/judger-id_18 org-emphasis-regexp-components Sarasa\ Fixed\ J tramp-gvfs-handle-copy-file tramp-do-copy-or-rename-file-out-of-band entropy/emacs-org-keymap-group-$common-open hexie/subr-org-subhead-exists-p _message hexie/api-core-registry-pos-obj eemacs-use-package/hydra-hollow-defer-parse/for-entropy-open-with/judger-id_59 Backward\ 1\ Year cl-print--preprocess Find\ file\ in\ directory selinux-context Insert\ Diary\ Entry wicon archive_type conf-space-mode-map 0 cl--struct-epg-signature-p entropy/cl-read-file-name \" cpbdins $ test-command Info-apropos-find-file \' :name-match M-kp-down tramp-cache-data org-babel-results-keyword eglot-autoshutdown dont-create not-at-beginning-of-line f-empty\? expired calendar-debug-sexp ...] :predicate #f(compiled-function (sym) #<bytecode 0x155ee121eced>) :require-match t :history counsel-M-x-history :action counsel-M-x-action :keymap (keymap (67108908 . counsel--info-lookup-symbol) (67108910 . counsel-find-symbol)) :initial-input nil :caller counsel-M-x)
    counsel-M-x()
    funcall-interactively(counsel-M-x)
    call-interactively(counsel-M-x nil nil)
    command-execute(counsel-M-x)

#+end_example

Its main cause that we patched =turn-on-font-lock= with
=entropy/emacs--supress-fontlock-mode=, why? maybe some clojure issue?

So that we now temporally fix it by using an
=entropy/emacs-large-file-warning-threshold= top level declaration to
avoid it and bind =large-file-warning-threshold= value to its value at
init time.

- [2022-05-05 Thu 14:47:03] : fix up done

  I forget the ~let~ binding case and the =nil= is meaningful to
  =large-file-warning-threshold=.

  For now we make =entropy/emacs-large-file-warning-threshold= as
  const and using ~entropy/emacs-large-file-warning-threshold-get~ to
  handle the result.

** TODO newsticker buggy
:PROPERTIES:
:CUSTOM_ID: h-936e4fb3-57d7-4958-89d9-a1cdfb52c495
:END:
#+begin_example
Error: HTML rendering failed: args-out-of-range, (*Newsticker Item* #<marker at 3538 in *Newsticker List*> #<marker (moves after insertion) at 3595 in *Newsticker List*>)
#+end_example

This bug when hint item in *Virtual Feeds* list.

Issues on emacs versions: 27.2, 28.0.91

*Reproduction:*

Run the bash file [[./h-936e4fb3-57d7-4958-89d9-a1cdfb52c495/start.sh]]

** TODO emacs-rime bug when =ivy-dynamic-exhibit-delay-ms= larger than 0
:PROPERTIES:
:CUSTOM_ID: h-1c9af04d-403f-4050-a8eb-778fc47ff8de
:END:

- emacs-vesion: any
- system-platform: any


*Bug description:*

When =ivy-dynamic-exhibit-delay-ms= larger than 0 the emacs-rime
~rime--minibuffer-message~ will trigger 'args-out-of-range' error for
its ~delete-region~ subroutine for cleaning the current candidates
prompts inserted as.

This bug only triggering when using DEL keystroke in the middle of
typing when in the minibuffr while some operation rely on ~ivy-read~
(and aslo using ~completing-read~ when =ivy-mode= or =counsel-mode=
enabled globally).

This bug also messes up the minibuffer prompts region in the occasion
descripted in above paragraph which points the pre-completion chars to
the beginning of the minibuffer.

*Reproduce:*

Run: [[./h-1c9af04d-403f-4050-a8eb-778fc47ff8de/run.sh]]

** DONE emacs 29 ~commandp~ check function ~find-file~ loop without termination while ~find-file~ is adviced nested up to 20 level
CLOSED: [2022-08-14 Sun 12:23]
:PROPERTIES:
:CUSTOM_ID: h:cf1dab14-2d89-4369-82e1-1a4e298fcfd3
:END:

It seems the new =oclosure= internal API invocation caused this issue.

Reproduce:

1. ensure emacs 29 is installed and can be found in the =PATH= and
   assume the caller is =emacs-29=

2. run the follow pre-defined reproduction:

#+begin_src sh
  sh ./'h:cf1dab14-2d89-4369-82e1-1a4e298fcfd3'/reproduce.sh emacs-29
#+end_src

*** [2022-08-11 Thu 12:57:06] report bug to [[bug-gnu-emacs@gnu.org]]
:PROPERTIES:
:CUSTOM_ID: h:fb709ea6-fa3d-435c-9147-f1b16314dbdc
:END:

Bug id is: =#57115=

Visist at https://debbugs.gnu.org/cgi/bugreport.cgi?bug=57115 or
discussed on https://lists.gnu.org/archive/html/bug-gnu-emacs/2022-08/msg00897.html

*** [2022-08-14 Sun 12:20:35] emacs devel has fixed this bug
:PROPERTIES:
:CUSTOM_ID: h:bcf0ed65-50fa-40e9-8030-d0300ecfdef7
:END:

emacs devel commit: emacs devel master: =dd2973bf504= Stefan Monnier
has fixed this bug or maybe? since I test without any problem now.

commit info:

#+begin_src diff
  @ dd2973bf5040d26d29a937d252eeaf2884dca9fb
  Author:     Stefan Monnier <monnier@iro.umontreal.ca>
  AuthorDate: Sat Aug 13 12:03:22 2022 -0400
  Commit:     Stefan Monnier <monnier@iro.umontreal.ca>
  CommitDate: Sat Aug 13 12:04:29 2022 -0400

  Parent:     a1cf3b96f84 ; Fix documentation of 'deactivate-mark'

  nadvice.el: Avoid exponential blow up in interactive-form recursion

  ,* lisp/emacs-lisp/nadvice.el (advice--interactive-form): Sink the call
  to `commandp` into the autoloaded function case since it's redundant in
  the other branch.
  (advice--make-interactive-form): Take just the interactive forms rather
  than the actual functions as arguments.
  (oclosure-interactive-form): Use `advice--interactive-form` rather than
  `commandp` since we'd call `advice--interactive-form` afterwards anyway.

  1 file changed, 13 insertions(+), 13 deletions(-)
  lisp/emacs-lisp/nadvice.el | 26 +++++++++++++-------------

  modified   lisp/emacs-lisp/nadvice.el
  @@ -167,31 +167,31 @@ advice-eval-interactive-spec

   (defun advice--interactive-form (function)
     "Like `interactive-form' but tries to avoid autoloading functions."
  -  (when (commandp function)
  -    (if (not (and (symbolp function) (autoloadp (indirect-function function))))
  -        (interactive-form function)
  -      `(interactive (advice-eval-interactive-spec
  +  (if (not (and (symbolp function) (autoloadp (indirect-function function))))
  +      (interactive-form function)
  +    (when (commandp function)
  +      `(interactive (advice--eval-interactive-spec
                        (cadr (interactive-form ',function)))))))

  -(defun advice--make-interactive-form (function main)
  +(defun advice--make-interactive-form (iff ifm)
     ;; TODO: make it so that interactive spec can be a constant which
     ;; dynamically checks the advice--car/cdr to do its job.
     ;; For that, advice-eval-interactive-spec needs to be more faithful.
  -  (let* ((iff (advice--interactive-form function))
  -         (ifm (advice--interactive-form main))
  -         (fspec (cadr iff)))
  +  (let* ((fspec (cadr iff)))
       (when (eq 'function (car-safe fspec)) ;; Macroexpanded lambda?
  -      (setq fspec (nth 1 fspec)))
  +      (setq fspec (eval fspec t)))
       (if (functionp fspec)
           `(funcall ',fspec ',(cadr ifm))
         (cadr (or iff ifm)))))


   (cl-defmethod oclosure-interactive-form ((ad advice) &optional _)
  -  (let ((car (advice--car ad))
  -        (cdr (advice--cdr ad)))
  -    (when (or (commandp car) (commandp cdr))
  -      `(interactive ,(advice--make-interactive-form car cdr)))))
  +  (let* ((car (advice--car ad))
  +         (cdr (advice--cdr ad))
  +         (ifa (advice--interactive-form car))
  +         (ifd (advice--interactive-form cdr)))
  +    (when (or ifa ifd)
  +      `(interactive ,(advice--make-interactive-form ifa ifd)))))

   (cl-defmethod cl-print-object ((object advice) stream)
     (cl-assert (advice--p object))
#+end_src

** TODO emacs-28.(1&2) =tramp-archive= file handler fatal
:PROPERTIES:
:CUSTOM_ID: h:02882923-4531-4775-9ae4-27c809f90f6e
:END:

Tramp archive using simple magick filename regexp matching, and its
internal =tramp-archive-file-name-handler-alist='s some corresponding
implementation are not follow the equalization API defination of
origin function, thus for most of tramp internal errors will pollute
the current emacs main thread's operations. (e.g. local directory
naming as an archive name will also invoking tramp-archive methods
which throw out many more problems while its magick filename I/O
deals)

Try below elisp snippets: [NOTE: below bug reproduction has no-effects
since emacs-28.2 since some improvements and fix in `tramp' but still
has this bug in its more deeper core parts i.e. `tramp-gvfs' ]

#+begin_src elisp
(entropy/emacs-test-emacs-with-pure-setup-with-form
 "tramp-archive-enabled-bug-reproduce"
 :use-current-package-user-dir nil
 :emacs-invocation-name "emacs-28.1"
 '(progn
    (setq debug-on-error t)
    (setq tramp-archive-enabled t)
    (file-directory-p
     "~/.config/entropy-config/\
entropy-emacs/entropy-emacs/annex/emacs-src/\
test/lisp/net/tramp-archive-resources/foo.iso/foo")
    ))
#+end_src

- [2022-09-21 Wed 12:20:16] new errors:

In emacs with native compilation feature
: tramp-archive-file-name-handler: Variable binding depth exceeds max-specpdl-size
in which case the backtrace is like:
#+begin_example
  Debugger entered--Lisp error: (file-error "Cannot open load file" "Too many open files" "/usr/share/emacs/s...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/share/emacs/28.2/lisp/net/tramp-archive.el" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/net/tramp-archive-resources/foo.iso/")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/share/emacs/28.2/lisp/net/tramp-archive.el" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/net/tramp-archive-resources/foo.iso/")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/s..." "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/net/tramp-archive-resources/foo.iso/" nil)
    directory-files("/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/net/tramp-archive-resources/foo.iso/" t)
    (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el (file-name-nondirectory el))) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (let ((default-directory (let ((dfd-rtn-val (progn (expand-file-name dir-root)))) (if (stringp dfd-rtn-val) nil (signal 'wrong-type-argument (list 'stringp (format "directory name: %s" dfd-rtn-val)))) (if (or (string-empty-p dfd-rtn-val) (not (directory-name-p dfd-rtn-val))) nil (setq dfd-rtn-val (directory-file-name dfd-rtn-val))) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el (file-name-nondirectory el))) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda (x) (let (... rtn) (if ... ... ...) (if rtn nil ...) rtn)) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite))))))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-only-regular-file :with-only-regular-directory :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-only-regular..." (car --cl-keys--)))))) (let ((default-directory (let ((dfd-rtn-val (progn ...))) (if (stringp dfd-rtn-val) nil (signal 'wrong-type-argument (list ... ...))) (if (or (string-empty-p dfd-rtn-val) (not ...)) nil (setq dfd-rtn-val (directory-file-name dfd-rtn-val))) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el ...)) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda (x) (let ... ... ... rtn)) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite)))))))
    (let* ((with-only-regular-file (car (cdr (plist-member --cl-rest-- ':with-only-regular-file)))) (with-only-regular-directory (car (cdr (plist-member --cl-rest-- ':with-only-regular-directory))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-only-regular..." (car --cl-keys--)))))) (let ((default-directory (let ((dfd-rtn-val ...)) (if (stringp dfd-rtn-val) nil (signal ... ...)) (if (or ... ...) nil (setq dfd-rtn-val ...)) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el ...)) (if (string-match-p directory-files-no-dot-files-regexp ...) (setq rtn-lite ...)) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda ... ...) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite))))))))
    entropy/emacs-list-dir-lite("/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    (and this-should-do (entropy/emacs-list-dir-lite this-root))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("foo.iso" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ... ... ...)) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") ...) (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil)) :remain--not-calling-at-root 5 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/ema..." :remain--prev-rel-path ("test" "lisp" "net" "tramp-archive-resources") :remain--parent-subdir-nth-for-current 0 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "tramp-archive-resources" :dir-subdirs-names ("foo.iso") :dir-subfiles-names ("foo.tar.gz") :dir-nth-pos-of-parent-subdirs 6 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "net" :dir-subdirs-names ("dbus-resources" "mailcap-resources" "netrc-resources" "network-stream-resources" "ntlm-resources" "shr-resources" "tramp-archive-resources") :dir-subfiles-names ("browse-url-tests.el" "dbus-tests.el" "dig-tests.el" "gnutls-tests.el" "hmac-md5-tests.el" "mailcap-tests.el" "netrc-tests.el" "network-stream-tests.el" "newsticker-tests.el" "nsm-tests.el" "ntlm-tests.el" "puny-tests.el" "rcirc-tests.el" "rfc2104-tests.el" "sasl-cram-tests.el" "sasl-scram-rfc-tests.el" "sasl-tests.el" "secrets-tests.el" "shr-tests.el" "socks-tests.el" "tramp-archive-tests.el" "tramp-tests.el" "webjump-tests.el") :dir-nth-pos-of-parent-subdirs 20 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" ...) :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs ... :dir-user-attrs nil :dir-rel-path ... :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net") :dir-rel-path-level 3) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net" "tramp-archive-resources") :dir-rel-path-level 4))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("tramp-archive-resources" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ... ... ...)) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") ...) (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil)) :remain--not-calling-at-root 4 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/ema..." :remain--prev-rel-path ("test" "lisp" "net") :remain--parent-subdir-nth-for-current 6 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "net" :dir-subdirs-names ("dbus-resources" "mailcap-resources" "netrc-resources" "network-stream-resources" "ntlm-resources" "shr-resources" "tramp-archive-resources") :dir-subfiles-names ("browse-url-tests.el" "dbus-tests.el" "dig-tests.el" "gnutls-tests.el" "hmac-md5-tests.el" "mailcap-tests.el" "netrc-tests.el" "network-stream-tests.el" "newsticker-tests.el" "nsm-tests.el" "ntlm-tests.el" "puny-tests.el" "rcirc-tests.el" "rfc2104-tests.el" "sasl-cram-tests.el" "sasl-scram-rfc-tests.el" "sasl-tests.el" "secrets-tests.el" "shr-tests.el" "socks-tests.el" "tramp-archive-tests.el" "tramp-tests.el" "webjump-tests.el") :dir-nth-pos-of-parent-subdirs 20 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" ...) :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p t :dir-name "." :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net") :dir-rel-path-level 3))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("net" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level ...) (dir-is-root ...) (dir-subfiles ...) (dir-pare-attrs ...) (dir-pare-subfiles ...) (dir-end-of-pare-p ...)) (if (= level 0) (progn ...)) (cond (... ...) (... nil) (... ... ...) (t ... ...)))) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* ... ...))) (cond (use-org-style (cond (end-call-p ...) (t ... ...))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat ... dir-indent-stack "") file-indent-inst (mapconcat ... ... "") file-indent-as-end-inst (mapconcat ... ... "")) (cond (end-call-p ...) (t ...)))) nil)) :remain--not-calling-at-root 3 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src/test/..." :remain--prev-rel-path ("test" "lisp") :remain--parent-subdir-nth-for-current 20 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test/..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" "url" "vc" "xdg-resources") :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" "epg-tests.el" "faces-tests.el" "ffap-tests.el" "filenotify-tests.el" "files-tests.el" "files-x-tests.el" "find-cmd-tests.el" "font-lock-tests.el" "format-spec-tests.el" "help-fns-tests.el" "help-mode-tests.el" "help-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test" :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("lisp" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :remain--not-calling-at-root 2 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src/test" :remain--prev-rel-path ("test") :remain--parent-subdir-nth-for-current 3 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test" :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("test" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :remain--not-calling-at-root 1 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src" :remain--prev-rel-path nil :remain--parent-subdir-nth-for-current 16 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("emacs-src" t :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #4) (chase-func closure #6 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack) (file-indent-tail-stack) (dir-indent-stack "    " "│   " "│   " "└── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files) (buffer . #<buffer *haha*>) (top-dir . "emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :with-level nil :with-filter nil)
    (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter))
    (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- (length node-nes) brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...)))))) (setq map-func #'(lambda (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name ... dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path ... ...)) (dir-subfiles (and with-files ...)) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda ... ...)) (cond (use-org-style (cond ... ...)) (t (funcall chase-func x) (setq dir-indent-inst ... file-indent-inst ... file-indent-as-end-inst ...) (cond ... ...))) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t)
    (let* ((dir-face (or dir-face (progn (if (featurep 'dired) nil (require 'dired)) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- (length node-nes) brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ((level ...) (dir-is-root ...) (dir-subfiles ...) (dir-pare-attrs ...) (dir-pare-subfiles ...) (dir-end-of-pare-p ...)) (if (= level 0) (progn ...)) (cond (... ...) (... nil) (... ... ...) (t ... ...))))) (setq map-func #'(lambda (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:dir-face :file-face :branch-str :branch-leaf-end-str :branch-leaf-non-end-str :leaf-str :use-org-style :with-level :with-filter :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:dir-face :file-fa..." (car --cl-keys--)))))) (let* ((dir-face (or dir-face (progn (if (featurep ...) nil (require ...)) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- ... brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* (... ... ... ... ... ...) (if ... ...) (cond ... ... ... ...)))) (setq map-func #'(lambda (x &optional end-call-p) (let* (... ... ... ... ... ... ... ... dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func ...) (cond ... ...) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t)))
    (let* ((dir-face (car (cdr (plist-member --cl-rest-- ':dir-face)))) (file-face (car (cdr (plist-member --cl-rest-- ':file-face)))) (branch-str (car (cdr (plist-member --cl-rest-- ':branch-str)))) (branch-leaf-end-str (car (cdr (plist-member --cl-rest-- ':branch-leaf-end-str)))) (branch-leaf-non-end-str (car (cdr (plist-member --cl-rest-- ':branch-leaf-non-end-str)))) (leaf-str (car (cdr (plist-member --cl-rest-- ':leaf-str)))) (use-org-style (car (cdr (plist-member --cl-rest-- ':use-org-style)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:dir-face :file-fa..." (car --cl-keys--)))))) (let* ((dir-face (or dir-face (progn (if ... nil ...) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string ... 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ... ... ...))) (setq map-func #'(lambda (x &optional end-call-p) (let* ... ... ... nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t))))
    entropy/emacs-print-dir-recursively("emacs-src" #<buffer *haha*>)
    eval-expression((entropy/emacs-print-dir-recursively "emacs-src" (get-buffer-create "*haha*")) nil nil 127)
    funcall-interactively(eval-expression (entropy/emacs-print-dir-recursively "emacs-src" (get-buffer-create "*haha*")) nil nil 127)
    command-execute(eval-expression)

#+end_example

In emacs without native compilation feature
: Debugger entered--Lisp error: (error "Recursive load" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc")
in which case the backtrace is like:
#+begin_example
  Debugger entered--Lisp error: (error "Recursive load" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/usr/share/emacs/28.2/lisp/net/tramp-archive.elc" "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    tramp-archive-file-name-handler(expand-file-name "/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n..." nil)
    directory-files("/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n..." t)
    (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el (file-name-nondirectory el))) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (let ((default-directory (let ((dfd-rtn-val (progn (expand-file-name dir-root)))) (if (stringp dfd-rtn-val) nil (signal 'wrong-type-argument (list 'stringp (format "directory name: %s" dfd-rtn-val)))) (if (or (string-empty-p dfd-rtn-val) (not (directory-name-p dfd-rtn-val))) nil (setq dfd-rtn-val (directory-file-name dfd-rtn-val))) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el (file-name-nondirectory el))) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda (x) (let (... rtn) (if ... ... ...) (if rtn nil ...) rtn)) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite))))))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-only-regular-file :with-only-regular-directory :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-only-regular..." (car --cl-keys--)))))) (let ((default-directory (let ((dfd-rtn-val (progn ...))) (if (stringp dfd-rtn-val) nil (signal 'wrong-type-argument (list ... ...))) (if (or (string-empty-p dfd-rtn-val) (not ...)) nil (setq dfd-rtn-val (directory-file-name dfd-rtn-val))) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el (car --dolist-tail--))) (if (string-match-p directory-files-no-dot-files-regexp (if not-abs el ...)) (setq rtn-lite (cons el rtn-lite))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda (x) (let ... ... ... rtn)) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite)))))))
    (let* ((with-only-regular-file (car (cdr (plist-member --cl-rest-- ':with-only-regular-file)))) (with-only-regular-directory (car (cdr (plist-member --cl-rest-- ':with-only-regular-directory))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-only-regular..." (car --cl-keys--)))))) (let ((default-directory (let ((dfd-rtn-val ...)) (if (stringp dfd-rtn-val) nil (signal ... ...)) (if (or ... ...) nil (setq dfd-rtn-val ...)) (file-name-as-directory dfd-rtn-val))) rtn-lite) (let ((--dolist-tail-- (directory-files default-directory (not not-abs)))) (while --dolist-tail-- (let ((el ...)) (if (string-match-p directory-files-no-dot-files-regexp ...) (setq rtn-lite ...)) (setq --dolist-tail-- (cdr --dolist-tail--))))) (if rtn-lite (progn (entropy/emacs-list-map-replace #'(lambda ... ...) rtn-lite) (if (setq rtn-lite (cl-delete nil rtn-lite)) (progn (nreverse rtn-lite))))))))
    entropy/emacs-list-dir-lite("/home/fake-user/.emacs.d/annex/emacs-src/test/lisp/n...")
    (and this-should-do (entropy/emacs-list-dir-lite this-root))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("foo.iso" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ... ... ...)) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") ...) (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil)) :remain--not-calling-at-root 5 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/ema..." :remain--prev-rel-path ("test" "lisp" "net" "tramp-archive-resources") :remain--parent-subdir-nth-for-current 0 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "tramp-archive-resources" :dir-subdirs-names ("foo.iso") :dir-subfiles-names ("foo.tar.gz") :dir-nth-pos-of-parent-subdirs 6 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "net" :dir-subdirs-names ("dbus-resources" "mailcap-resources" "netrc-resources" "network-stream-resources" "ntlm-resources" "shr-resources" "tramp-archive-resources") :dir-subfiles-names ("browse-url-tests.el" "dbus-tests.el" "dig-tests.el" "gnutls-tests.el" "hmac-md5-tests.el" "mailcap-tests.el" "netrc-tests.el" "network-stream-tests.el" "newsticker-tests.el" "nsm-tests.el" "ntlm-tests.el" "puny-tests.el" "rcirc-tests.el" "rfc2104-tests.el" "sasl-cram-tests.el" "sasl-scram-rfc-tests.el" "sasl-tests.el" "secrets-tests.el" "shr-tests.el" "socks-tests.el" "tramp-archive-tests.el" "tramp-tests.el" "webjump-tests.el") :dir-nth-pos-of-parent-subdirs 20 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" ...) :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs ... :dir-user-attrs nil :dir-rel-path ... :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net") :dir-rel-path-level 3) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net" "tramp-archive-resources") :dir-rel-path-level 4))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("tramp-archive-resources" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ... ... ...)) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") ...) (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil)) :remain--not-calling-at-root 4 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/ema..." :remain--prev-rel-path ("test" "lisp" "net") :remain--parent-subdir-nth-for-current 6 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "net" :dir-subdirs-names ("dbus-resources" "mailcap-resources" "netrc-resources" "network-stream-resources" "ntlm-resources" "shr-resources" "tramp-archive-resources") :dir-subfiles-names ("browse-url-tests.el" "dbus-tests.el" "dig-tests.el" "gnutls-tests.el" "hmac-md5-tests.el" "mailcap-tests.el" "netrc-tests.el" "network-stream-tests.el" "newsticker-tests.el" "nsm-tests.el" "ntlm-tests.el" "puny-tests.el" "rcirc-tests.el" "rfc2104-tests.el" "sasl-cram-tests.el" "sasl-scram-rfc-tests.el" "sasl-tests.el" "secrets-tests.el" "shr-tests.el" "socks-tests.el" "tramp-archive-tests.el" "tramp-tests.el" "webjump-tests.el") :dir-nth-pos-of-parent-subdirs 20 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" ...) :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/ema..." :dir-is-root-p t :dir-name "." :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2) :dir-user-attrs nil :dir-rel-path ("test" "lisp" "net") :dir-rel-path-level 3))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("net" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level ...) (dir-is-root ...) (dir-subfiles ...) (dir-pare-attrs ...) (dir-pare-subfiles ...) (dir-end-of-pare-p ...)) (if (= level 0) (progn ...)) (cond (... ...) (... nil) (... ... ...) (t ... ...)))) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* ... ...))) (cond (use-org-style (cond (end-call-p ...) (t ... ...))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat ... dir-indent-stack "") file-indent-inst (mapconcat ... ... "") file-indent-as-end-inst (mapconcat ... ... "")) (cond (end-call-p ...) (t ...)))) nil)) :remain--not-calling-at-root 3 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src/test/..." :remain--prev-rel-path ("test" "lisp") :remain--parent-subdir-nth-for-current 20 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test/..." :dir-is-root-p nil :dir-name "lisp" :dir-subdirs-names ("align-resources" "bookmark-resources" "calc" "calendar" "cedet" "custom-resources" "emacs-lisp" "emulation" "epg-resources" "erc" "eshell" "faces-resources" "files-resources" "gnus" "hfy-cmap-resources" "image" "international" "mail" "mh-e" "minibuffer-resources" "net" "nxml" "obsolete" "org" "pcmpl-linux-resources" "play" "progmodes" "saveplace-resources" "so-long-tests" "term" "textmodes" "time-resources" "url" "vc" "xdg-resources") :dir-subfiles-names ("abbrev-tests.el" "align-tests.el" "allout-tests.el" "allout-widgets-tests.el" "ansi-color-tests.el" "apropos-tests.el" "arc-mode-tests.el" "auth-source-pass-tests.el" "auth-source-tests.el" "autoinsert-tests.el" "autorevert-tests.el" "battery-tests.el" "bookmark-tests.el" "buff-menu-tests.el" "button-tests.el" "calculator-tests.el" "char-fold-tests.el" "color-tests.el" "comint-tests.el" "completion-tests.el" "cus-edit-tests.el" "custom-tests.el" "dabbrev-tests.el" "delim-col-tests.el" "descr-text-tests.el" "dired-aux-tests.el" "dired-tests.el" "dired-x-tests.el" "dom-tests.el" "electric-tests.el" "elide-head-tests.el" "epg-config-tests.el" "epg-tests.el" "faces-tests.el" "ffap-tests.el" "filenotify-tests.el" "files-tests.el" "files-x-tests.el" "find-cmd-tests.el" "font-lock-tests.el" "format-spec-tests.el" "help-fns-tests.el" "help-mode-tests.el" "help-tests.el" ...) :dir-nth-pos-of-parent-subdirs 3 :dir-nth-pos-is-at-end-of-parent-subdirs 0 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test" :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1) :dir-user-attrs nil :dir-rel-path ("test" "lisp") :dir-rel-path-level 2))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("lisp" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :remain--not-calling-at-root 2 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src/test" :remain--prev-rel-path ("test") :remain--parent-subdir-nth-for-current 3 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src/test" :dir-is-root-p nil :dir-name "test" :dir-subdirs-names ("data" "infra" "lib-src" "lisp" "manual" "misc" "src") :dir-subfiles-names ("ChangeLog.1" "Makefile.in" "README" "file-organization.org") :dir-nth-pos-of-parent-subdirs 16 :dir-nth-pos-is-at-end-of-parent-subdirs 1 :dir-parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0) :dir-user-attrs nil :dir-rel-path ("test") :dir-rel-path-level 1))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("test" t :with-attributes nil :with-level nil :with-filter nil :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #10) (chase-func closure #12 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :remain--not-calling-at-root 1 :remain--top-dir-expand-of "/home/fake-user/.emacs.d/annex/emacs-src" :remain--prev-rel-path nil :remain--parent-subdir-nth-for-current 16 :remain--parent-attrs (:dir-abspath "/home/fake-user/.emacs.d/annex/emacs-src" :dir-is-root-p t :dir-name "." :dir-subdirs-names ("admin" "build-aux" "doc" "etc" "leim" "lib" "lib-src" "lisp" "lwlib" "m4" "modules" "msdos" "nextstep" "nt" "oldXMenu" "src" "test") :dir-subfiles-names (".clang-format" ".dir-locals.el" ".git" ".gitattributes" ".gitignore" ".gitlab-ci.yml" "BUGS" "CONTRIBUTE" "COPYING" "ChangeLog.1" "ChangeLog.2" "ChangeLog.3" "GNUmakefile" "INSTALL" "INSTALL.REPO" "Makefile.in" "README" "autogen.sh" "config.bat" "configure.ac" "make-dist") :dir-nth-pos-of-parent-subdirs nil :dir-nth-pos-is-at-end-of-parent-subdirs nil :dir-parent-attrs nil :dir-user-attrs nil :dir-rel-path nil :dir-rel-path-level 0))
    (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)
    (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn))
    (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))
    (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))
    (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))
    (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))
    (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir (car --dolist-tail--))) (setq rtn (cons (entropy/emacs-list-dir-subdirs-recursively sub-dir not-abs :with-attributes with-attributes :with-level with-level :with-filter with-filter :map-func map-func :remain--not-calling-at-root use-level :remain--top-dir-expand-of expand-of :remain--prev-rel-path this-rel-path :remain--parent-subdir-nth-for-current parenth :remain--parent-attrs default-attrs) rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))
    (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ((sub-dir ...)) (setq rtn (cons ... rtn)) (setq parenth (1+ parenth)) (if (funcall should-operate-subdirs-judge-func) nil (throw :exit-map-subdirs t)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))
    (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let (...) (setq rtn ...) (setq parenth ...) (if ... nil ...) (setq --dolist-tail-- ...))))))))
    (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn (if ... 1 0))) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p (not not-abs)) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs (progn this-root)))) (catch :exit-map-subdirs (let ((--dolist-tail-- subdirs)) (while --dolist-tail-- (let ... ... ... ... ...))))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))))
    (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ((inner-assoc ...)) (if with-filter (cond ... ... ...) t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'(lambda ... ...) subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn (mapcar get-fname-func fnames))))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-map-func-end-call))))) (should-operate-subdirs-judge-func #'(lambda nil (not (and (entropy/emacs-strict-plistp user-spec-attrs) (plist-get user-spec-attrs :should-not-operate-subdirs))))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current (progn ...)) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs (plist-put default-attrs :dir-user-attrs user-spec-attrs)))))) (let ((proper-top-dir (cond ((and root-calling-p not-abs) ".") ((and root-calling-p ...) (expand-file-name top-dir)) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level (1+ this-level)) (expand-of (if not-abs ...))) (catch :exit-map-subdirs (let (...) (while --dolist-tail-- ...)))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))
    (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* (...) (if with-filter ... t)))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar #'... subitems)))) (subdirs (and this-should-do (delete nil (mapcar #'... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x (file-name-nondirectory x)))) (get-fnames-func #'(lambda (fnames) (if fnames (progn ...)))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not (and ... ...)))) (should-operate-subdirs-judge-func #'(lambda nil (not (and ... ...)))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names (funcall get-fnames-func subdirs) :dir-subfiles-names (funcall get-fnames-func subfiles) :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs (if remain--parent-subdir-nth-for-current ...) :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn (setq default-attrs ...))))) (let ((proper-top-dir (cond (... ".") (... ...) (t top-dir)))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ((parenth 0) (use-level ...) (expand-of ...)) (catch :exit-map-subdirs (let ... ...))))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn)))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:with-attributes :with-level :with-filter :map-func :remain--not-calling-at-root :remain--top-dir-expand-of :remain--parent-attrs :remain--parent-subdir-nth-for-current :remain--prev-rel-path :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda (&rest args) (let* ... ...))) (subfiles (and use-attrs-p this-should-do (delete nil (mapcar ... subitems)))) (subdirs (and this-should-do (delete nil (mapcar ... subitems)))) (get-fname-func #'(lambda (x) (if not-abs x ...))) (get-fnames-func #'(lambda (fnames) (if fnames ...))) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil (not ...))) (should-operate-subdirs-judge-func #'(lambda nil (not ...))) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path (list this-dirname)))) (if use-attrs-p (progn (setq default-attrs (list :dir-abspath this-root :dir-is-root-p root-calling-p :dir-name this-dirname :dir-subdirs-names ... :dir-subfiles-names ... :dir-nth-pos-of-parent-subdirs remain--parent-subdir-nth-for-current :dir-nth-pos-is-at-end-of-parent-subdirs ... :dir-parent-attrs remain--parent-attrs :dir-user-attrs nil :dir-rel-path this-rel-path :dir-rel-path-level this-level)))) (if map-func (progn (setq user-spec-attrs (funcall map-func default-attrs)) (if user-spec-attrs (progn ...)))) (let ((proper-top-dir (cond ... ... ...))) (if with-attributes (setq this-node-car (cons proper-top-dir default-attrs)) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...))) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let (... ... ...) (catch :exit-map-subdirs ...)))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs 'end-call-p)))) (reverse rtn))))
    (let* ((with-attributes (car (cdr (plist-member --cl-rest-- ':with-attributes)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter)))) (map-func (car (cdr (plist-member --cl-rest-- ':map-func)))) (remain--not-calling-at-root (car (cdr (plist-member --cl-rest-- ':remain--not-calling-at-root)))) (remain--top-dir-expand-of (car (cdr (plist-member --cl-rest-- ':remain--top-dir-expand-of)))) (remain--parent-attrs (car (cdr (plist-member --cl-rest-- ':remain--parent-attrs)))) (remain--parent-subdir-nth-for-current (car (cdr (plist-member --cl-rest-- ':remain--parent-subdir-nth-for-current)))) (remain--prev-rel-path (car (cdr (plist-member --cl-rest-- ':remain--prev-rel-path))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:with-attributes :..." (car --cl-keys--)))))) (progn (if with-level (progn (if (< with-level 1) (progn (user-error "[entropy/emacs-list-dir-subdirs-recursively]: leve..."))))) (let* ((root-calling-p (not remain--not-calling-at-root)) (this-level (if root-calling-p 0 remain--not-calling-at-root)) (this-root (if remain--top-dir-expand-of (expand-file-name top-dir remain--top-dir-expand-of) (expand-file-name top-dir))) (use-attrs-p (or with-attributes map-func)) (this-should-do (< this-level (or with-level most-positive-fixnum))) (subitems (and this-should-do (entropy/emacs-list-dir-lite this-root))) (filter-func #'(lambda ... ...)) (subfiles (and use-attrs-p this-should-do (delete nil ...))) (subdirs (and this-should-do (delete nil ...))) (get-fname-func #'(lambda ... ...)) (get-fnames-func #'(lambda ... ...)) this-dirname this-node-car this-rel-path default-attrs user-spec-attrs (should-run-map-func-for-endcall-judge-func #'(lambda nil ...)) (should-operate-subdirs-judge-func #'(lambda nil ...)) rtn) (catch :exit (setq this-dirname (if root-calling-p "." (funcall get-fname-func top-dir)) this-rel-path (if root-calling-p nil (append remain--prev-rel-path ...))) (if use-attrs-p (progn (setq default-attrs ...))) (if map-func (progn (setq user-spec-attrs ...) (if user-spec-attrs ...))) (let ((proper-top-dir ...)) (if with-attributes (setq this-node-car ...) (setq this-node-car proper-top-dir))) (setq rtn (cons this-node-car rtn)) (if subdirs nil (if (and map-func ...) (progn ...)) (throw :exit nil)) (if (and subdirs (funcall should-operate-subdirs-judge-func)) (progn (let ... ...))) (if (and map-func (funcall should-run-map-func-for-endcall-judge-func)) (progn (funcall map-func default-attrs ...)))) (reverse rtn)))))
    entropy/emacs-list-dir-subdirs-recursively("~/.emacs.d/annex/emacs-src" t :map-func (closure ((node-ees . "    ") (node-es . "└── ") (node-nees . "│   ") (node-nes . "├── ") (map-func . #4) (chase-func closure #6 (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...))))) (file-indent-tail-as-end-stack "│   " "└── ") (file-indent-tail-stack "│   " "├── ") (dir-indent-stack "│   " "│   " "│   " "├── ") (lfslen . 3) (lfs . "── ") (brleslen . 1) (brles . "└") (brlneslen . 1) (brlnes . "├") (brslen . 1) (brs . "│") (file-face . default) (dir-face . dired-directory) (with-filter) (with-level) (use-org-style) (leaf-str) (branch-leaf-non-end-str) (branch-leaf-end-str) (branch-str) (file-face) (dir-face) (--cl-rest--) (with-files . with-files) (buffer . #<buffer *haha*>) (top-dir . "~/.emacs.d/annex/emacs-src") t) (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name 'face dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path 'face 'shadow)) (dir-subfiles (and with-files (plist-get x :dir-subfiles-names))) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda (type &optional fname) (let* (... ...) (concat ":PROPERTIES:\n" ... ... ... ... ... ":END:\n")))) (cond (use-org-style (cond (end-call-p (if dir-subfiles ...)) (t (insert ...) (insert ...)))) (t (funcall chase-func x) (setq dir-indent-inst (mapconcat 'identity dir-indent-stack "") file-indent-inst (mapconcat 'identity (append ... file-indent-tail-stack) "") file-indent-as-end-inst (mapconcat 'identity (append ... file-indent-tail-as-end-stack) "")) (cond (end-call-p (if dir-subfiles ...)) (t (if dir-is-root-p ... ...))))) nil)) :with-level nil :with-filter nil)
    (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter))
    (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- (length node-nes) brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ((level (or level 0)) (dir-is-root (plist-get x :dir-is-root-p)) (dir-subfiles (and with-files ...)) (dir-pare-attrs (plist-get x :dir-parent-attrs)) (dir-pare-subfiles (and with-files ...)) (dir-end-of-pare-p (and ... ...))) (if (= level 0) (progn (setq dir-indent-stack nil file-indent-tail-stack nil file-indent-tail-as-end-stack nil))) (cond ((and dir-is-root ...) (setq dir-indent-stack ... file-indent-tail-stack ... file-indent-tail-as-end-stack ...)) ((and dir-is-root ...) nil) ((= level 0) (if dir-end-of-pare-p ... ... ...) (funcall chase-func dir-pare-attrs ...)) (t (if dir-end-of-pare-p ... ...) (funcall chase-func dir-pare-attrs ...)))))) (setq map-func #'(lambda (x &optional end-call-p) (let* ((dir-is-root-p (plist-get x :dir-is-root-p)) (dir-rel-level (plist-get x :dir-rel-path-level)) (dir-rel-pathlist (plist-get x :dir-rel-path)) (dir-name (plist-get x :dir-name)) (dir-name-inst (propertize dir-name ... dir-face)) (dir-abs-path (plist-get x :dir-abspath)) (dir-abs-path-inst (propertize dir-abs-path ... ...)) (dir-subfiles (and with-files ...)) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'(lambda ... ...)) (cond (use-org-style (cond ... ...)) (t (funcall chase-func x) (setq dir-indent-inst ... file-indent-inst ... file-indent-as-end-inst ...) (cond ... ...))) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t)
    (let* ((dir-face (or dir-face (progn (if (featurep 'dired) nil (require 'dired)) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- (length node-nes) brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ((level ...) (dir-is-root ...) (dir-subfiles ...) (dir-pare-attrs ...) (dir-pare-subfiles ...) (dir-end-of-pare-p ...)) (if (= level 0) (progn ...)) (cond (... ...) (... nil) (... ... ...) (t ... ...))))) (setq map-func #'(lambda (x &optional end-call-p) (let* ((dir-is-root-p ...) (dir-rel-level ...) (dir-rel-pathlist ...) (dir-name ...) (dir-name-inst ...) (dir-abs-path ...) (dir-abs-path-inst ...) (dir-subfiles ...) dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func #'...) (cond (use-org-style ...) (t ... ... ...)) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t))
    (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:dir-face :file-face :branch-str :branch-leaf-end-str :branch-leaf-non-end-str :leaf-str :use-org-style :with-level :with-filter :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:dir-face :file-fa..." (car --cl-keys--)))))) (let* ((dir-face (or dir-face (progn (if (featurep ...) nil (require ...)) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string (- ... brslen) 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* (... ... ... ... ... ...) (if ... ...) (cond ... ... ... ...)))) (setq map-func #'(lambda (x &optional end-call-p) (let* (... ... ... ... ... ... ... ... dir-indent-inst file-indent-inst file-indent-as-end-inst org-info-func) (setq org-info-func ...) (cond ... ...) nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t)))
    (let* ((dir-face (car (cdr (plist-member --cl-rest-- ':dir-face)))) (file-face (car (cdr (plist-member --cl-rest-- ':file-face)))) (branch-str (car (cdr (plist-member --cl-rest-- ':branch-str)))) (branch-leaf-end-str (car (cdr (plist-member --cl-rest-- ':branch-leaf-end-str)))) (branch-leaf-non-end-str (car (cdr (plist-member --cl-rest-- ':branch-leaf-non-end-str)))) (leaf-str (car (cdr (plist-member --cl-rest-- ':leaf-str)))) (use-org-style (car (cdr (plist-member --cl-rest-- ':use-org-style)))) (with-level (car (cdr (plist-member --cl-rest-- ':with-level)))) (with-filter (car (cdr (plist-member --cl-rest-- ':with-filter))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:dir-face :file-fa..." (car --cl-keys--)))))) (let* ((dir-face (or dir-face (progn (if ... nil ...) 'dired-directory))) (file-face (or file-face 'default)) (brs (or branch-str "│")) (brslen (length brs)) (brlnes (or branch-leaf-non-end-str "├")) (brlneslen (length brlnes)) (brles (or branch-leaf-end-str "└")) (brleslen (length brles)) (lfs (or leaf-str "── ")) (lfslen (length lfs)) dir-indent-stack file-indent-tail-stack file-indent-tail-as-end-stack chase-func map-func) (if (or (> brslen (+ brlneslen lfslen)) (> brslen (+ brleslen lfslen))) (progn (user-error "[entropy/emacs-print-dir-recursively]: BRANCH-STR ..." brs))) (let* ((node-nes (concat brlnes lfs)) (node-nees (concat brs (make-string ... 32))) (node-es (concat brles lfs)) (node-ees (make-string (length node-es) 32))) (setq chase-func #'(lambda (x &optional level) (let* ... ... ...))) (setq map-func #'(lambda (x &optional end-call-p) (let* ... ... ... nil))) (save-current-buffer (set-buffer buffer) (entropy/emacs-list-dir-subdirs-recursively top-dir t :map-func map-func :with-level with-level :with-filter with-filter)) t))))
    entropy/emacs-print-dir-recursively("~/.emacs.d/annex/emacs-src" #<buffer *haha*> with-files)
    (unwind-protect (1+ 'a) (if (buffer-live-p (get-buffer "*Backtrace*")) (save-current-buffer (set-buffer (get-buffer "*Backtrace*")) (debugger-quit))) (entropy/emacs-print-dir-recursively "~/.emacs.d/annex/emacs-src" (get-buffer-create "*haha*") 'with-files))
    (progn (if debug-on-error nil (setq debug-on-error t)) (unwind-protect (1+ 'a) (if (buffer-live-p (get-buffer "*Backtrace*")) (save-current-buffer (set-buffer (get-buffer "*Backtrace*")) (debugger-quit))) (entropy/emacs-print-dir-recursively "~/.emacs.d/annex/emacs-src" (get-buffer-create "*haha*") 'with-files)))
    (progn (progn (if debug-on-error nil (setq debug-on-error t)) (unwind-protect (1+ 'a) (if (buffer-live-p (get-buffer "*Backtrace*")) (save-current-buffer (set-buffer (get-buffer "*Backtrace*")) (debugger-quit))) (entropy/emacs-print-dir-recursively "~/.emacs.d/annex/emacs-src" (get-buffer-create "*haha*") 'with-files))))
    eval((progn (progn (if debug-on-error nil (setq debug-on-error t)) (unwind-protect (1+ 'a) (if (buffer-live-p (get-buffer "*Backtrace*")) (save-current-buffer (set-buffer (get-buffer "*Backtrace*")) (debugger-quit))) (entropy/emacs-print-dir-recursively "~/.emacs.d/annex/emacs-src" (get-buffer-create "*haha*") 'with-files)))) t)
    elisp--eval-last-sexp(nil)
    eval-last-sexp(nil)
    funcall-interactively(eval-last-sexp nil)
    call-interactively(eval-last-sexp)
    (let* ((gc-cons-threshold entropy/emacs-gc-threshold-basic) (gc-cons-percentage entropy/emacs-gc-percentage-basic)) (call-interactively 'eval-last-sexp))
    (setq rtn (let* ((gc-cons-threshold entropy/emacs-gc-threshold-basic) (gc-cons-percentage entropy/emacs-gc-percentage-basic)) (call-interactively 'eval-last-sexp)))
    (progn (setq rtn (let* ((gc-cons-threshold entropy/emacs-gc-threshold-basic) (gc-cons-percentage entropy/emacs-gc-percentage-basic)) (call-interactively 'eval-last-sexp))) (let ((eval-form nil) (orig-buff (current-buffer)) msg-core-get-func) (if byte-compile-type (progn (cond ((consp byte-compile-type) (let (...) (setq eval-form ...))) (t (setq eval-form rtn))) (setq msg-core-get-func #'(lambda nil (setq msg-core ...))) (let ((buffnm "*eemacs eval with byte-compile*") buff win confirm-p bytecmp-result) (display-buffer (setq buff (generate-new-buffer buffnm)) '(... ... ... ... ...) (selected-frame)) (if (setq win (get-buffer-window buff)) nil (error "[internal error] can not create eval exhibition wi...")) (save-current-buffer (set-buffer buff) (unwind-protect (let ... ... ... ... ... ... ...) (if confirm-p nil ... ... ...))) (funcall msg-core-get-func) (let* ((curmsg ...) (ignmsgs nil) (message ...) (progress-reporter ...)) (prog1 (let ... ... ...) (if progress-reporter ...) (if ... ...))))))) rtn)
    (if (or nil nil (yes-or-no-p (format "Really eval %s" 'last-sexp))) (progn (setq rtn (let* ((gc-cons-threshold entropy/emacs-gc-threshold-basic) (gc-cons-percentage entropy/emacs-gc-percentage-basic)) (call-interactively 'eval-last-sexp))) (let ((eval-form nil) (orig-buff (current-buffer)) msg-core-get-func) (if byte-compile-type (progn (cond ((consp byte-compile-type) (let ... ...)) (t (setq eval-form rtn))) (setq msg-core-get-func #'(lambda nil ...)) (let ((buffnm "*eemacs eval with byte-compile*") buff win confirm-p bytecmp-result) (display-buffer (setq buff ...) '... (selected-frame)) (if (setq win ...) nil (error "[internal error] can not create eval exhibition wi...")) (save-current-buffer (set-buffer buff) (unwind-protect ... ...)) (funcall msg-core-get-func) (let* (... ... ... ...) (prog1 ... ... ...)))))) rtn))
    (let (rtn msg-core (byte-compile-type nil)) (if (or nil nil (yes-or-no-p (format "Really eval %s" 'last-sexp))) (progn (setq rtn (let* ((gc-cons-threshold entropy/emacs-gc-threshold-basic) (gc-cons-percentage entropy/emacs-gc-percentage-basic)) (call-interactively 'eval-last-sexp))) (let ((eval-form nil) (orig-buff (current-buffer)) msg-core-get-func) (if byte-compile-type (progn (cond (... ...) (t ...)) (setq msg-core-get-func #'...) (let (... buff win confirm-p bytecmp-result) (display-buffer ... ... ...) (if ... nil ...) (save-current-buffer ... ...) (funcall msg-core-get-func) (let* ... ...))))) rtn)))
    entropy/emacs-lisp-elisp-eval-last-sexp()
    funcall-interactively(entropy/emacs-lisp-elisp-eval-last-sexp)
    call-interactively(entropy/emacs-lisp-elisp-eval-last-sexp nil nil)
    command-execute(entropy/emacs-lisp-elisp-eval-last-sexp)

#+end_example

It's triggerred by call `entropy/emacs-basic-dired/print-tree' for
print the dirctory "~/.emacs.d/annex/emacs-src" flow up to its subdir
"test/lisp/net/tramp-archive-resources/foo.iso".

But we can not reproduce its bug with entropy-emacs pure env tester
both of:
1) for interactively call ~entropy/emacs-basic-dired/print-tree~
#+begin_src elisp
  (entropy/emacs-run-body-with-eemacs-pure-env
   '(let ((buff (get-buffer-create "*haha*")))
      ;; forcely trigger an debug since some primitive error are not
      ;; forcely popup the debugger
      (unless debug-on-error (setq debug-on-error t))
      (dired "~/.emacs.d/annex/")
      (when (re-search-forward "emacs-src")
        (unwind-protect
            ;; a fake error
            (1+ 'a)
          (require 'entropy-emacs-package)
          (entropy/emacs-package-common-start)
          (require 'entropy-emacs-hydra-hollow)
          (require 'entropy-emacs-basic)
          ;; forcely tidy up old debugger informations while we should use new
          ;; since emacs will not print the debug tree if prevous debug tree is
          ;; not cleanup.
          (if (buffer-live-p (get-buffer "*Backtrace*"))
              (with-current-buffer (get-buffer "*Backtrace*")
                (debugger-quit)))
          (let ((current-prefix-arg 0))
            (call-interactively #'entropy/emacs-basic-dired/print-tree))))))
#+end_src

1) Or use its core of  ~entropy/emacs-print-dir-recursively~
#+begin_src elisp
  (entropy/emacs-run-body-with-eemacs-pure-env
   '(let ((buff (get-buffer-create "*haha*")))
      (switch-to-buffer buff)
      ;; forcely trigger an debug since some primitive error are not
      ;; forcely popup the debugger
      (unless debug-on-error (setq debug-on-error t))
      (unwind-protect
          ;; a fake error
          (1+ 'a)
        ;; forcely tidy up old debugger informations while we should use new
        ;; since emacs will not print the debug tree if prevous debug tree is
        ;; not cleanup.
        (if (buffer-live-p (get-buffer "*Backtrace*"))
            (with-current-buffer (get-buffer "*Backtrace*")
              (debugger-quit)))
        (entropy/emacs-print-dir-recursively
         "~/.emacs.d/annex/emacs-src"
         buff 'with-files))))
#+end_src

Thus it could only be reproduced while load entropy-emacs fully on. We
suspect its caused for some third-party libs or eemacs internal
fatals.

There's a temporally fix that is to required =tramp-archive= before
calling `entropy/emacs-basic-dired/print-tree' then anything is ok, so
as I guess for, the bug is related to tramp loading mechanism.

** TODO emacs-29 interactively usage cause circular list error where making emacs unusable for rest usage
:PROPERTIES:
:CUSTOM_ID: h:c5b6bd90-0662-4daa-877f-5be88c04ce2a
:END:

It's mainly caused by the mode-line-format segment
~mode-line-position~ of eemacs origin type mode line after my
investigation few days. And found by using =company-box= with its
subroutine ~company-box--with-icons-p~ which invoking ~posn-at-point~.

For now [2022-11-08 Tue 17:42:40] there's no lisp code reproducing
snippet can be built for thus since its a interactive problem just
when triggered by above usage description.

The mode-line refer bug detection is found by studing emacs source
code of ~make_lispy_position~ which is the primitive subroutine of
~posn-at-point~ at emacs master commit =b250f89e63a= and found that it
has some temporarily fixing snippet that may not be robust for
release.

* COMMENT Local Varaibles
:PROPERTIES:
:CUSTOM_ID: h-550f1e2d-23da-47d3-98e1-cd8be05baa7d
:END:
# Local Variables:
# fill-column: 70
# org-cycle-separator-lines: 8
# org-adapt-indentation: nil
# org-download-image-dir: "./img/"
# eval: (auto-fill-mode)
# End:
